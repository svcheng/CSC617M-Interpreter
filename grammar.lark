// =====================
// LEXER
// =====================

%import common.WS
%ignore WS

INVALID_IDENT.10: /\d+[a-zA-Z_]\w*/

%import common.SIGNED_INT       -> INT
%import common.SIGNED_FLOAT     -> FLOAT
%import common.ESCAPED_STRING   -> STRVAL
%import common.CNAME


IDENTIFIER.-1: CNAME // lower priority

BOOLVAL: "true" | "false"
CHARVAL: "'" /[ -~\n]/ "'" // any printable ASCII char + newline

// Keywords
LET: "let"
VAR: "var"
IF: "if"
ELSE: "else"
FOR: "for"
WHILE: "while"
REPEAT: "repeat"
UNTIL: "until"
RETURN: "return"
MAIN: "main"
RECORD: "record"
INT_T: "int"
FLOAT_T: "float"
BOOL_T: "bool"
CHAR_T: "char"
STR_T: "str"
ARR: "arr"
VOID: "void"
PRINT: "print"
SCAN: "scan"
CAST: "cast"

// =====================
// Program Structure
// =====================

program: type_decs func_decs main_block

type_decs: (type_dec)*
func_decs: (func_dec)*

main_block: MAIN ":" block
?block: "{" stmts "}"
stmts: stmt*

?stmt: const_dec
     | var_dec
     | assignment
     | conditional
     | for_loop
     | while_loop
     | repeat_loop
     | return_stmt
     | print_stmt
     | scan_stmt
     | invocation ";"

// =====================
// Declarations
// =====================

const_dec: LET IDENTIFIER "=" expr ";"
var_dec: VAR IDENTIFIER ":" datatype ";" -> var_dec_no_assign
       | VAR IDENTIFIER "=" expr ";"     -> var_dec_assign

type_dec: RECORD IDENTIFIER "{" field_list "}"
field_list: field ("," field)*
field: IDENTIFIER ":" datatype

func_dec: (datatype | VOID) IDENTIFIER "(" [field_list] ")" "{" stmts "}"

// =====================
// Types
// =====================
?datatype: not_array_type
         | array_type

not_array_type: basic_type
              | IDENTIFIER
basic_type: INT_T
          | FLOAT_T
          | BOOL_T
          | CHAR_T
          | STR_T
array_type: not_array_type ARR "[" exprs "]"

// =====================
// Statements
// =====================

assignment: lvalue "=" expr ";"

conditional: IF "(" expr ")" block (ELSE block)?

for_loop: FOR "(" IDENTIFIER ";" expr ";" expr ";" expr ")" block
while_loop: WHILE "(" expr ")" block
repeat_loop: REPEAT block UNTIL "(" expr ")" ";"

return_stmt: RETURN expr ";"
           | RETURN ";"

print_stmt: PRINT "(" expr ")" ";"
scan_stmt: SCAN "(" lvalue ")" ";"

?lvalue: IDENTIFIER
       | arr_access
       | field_access

// =====================
// Expressions
// =====================

?scalar: literal
        | IDENTIFIER
        | arr_access
        | field_access
        | invocation
        | cast

?literal: INT
        | FLOAT
        | BOOLVAL
        | CHARVAL
        | STRVAL

arr_access: IDENTIFIER "[" exprs "]"
field_access: IDENTIFIER ( "." IDENTIFIER )+

invocation: IDENTIFIER "(" [exprs] ")"
exprs: expr ("," expr)*

cast: CAST "(" expr "," STRVAL ")"

?expr: expr "||" e1      -> lor
     | e1
?e1: e1 "&&" e2          -> land
   | e2
?e2: e2 "==" e3          -> eq
   | e2 "!=" e3          -> ne
   | e3
?e3: e3 "<" e4           -> lt
   | e3 "<=" e4          -> le
   | e3 ">" e4           -> gt
   | e3 ">=" e4          -> ge
   | e4
?e4: e4 "+" e5           -> add
   | e4 "-" e5           -> sub
   | e5
?e5: e5 "*" factor       -> mul
   | e5 "/" factor       -> div
   | factor
?factor: scalar
       | "(" expr ")"
       | "!" expr        -> lnot
